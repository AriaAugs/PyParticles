<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>pyparticles.engine.simulation API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyparticles.engine.simulation</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyparticles.engine.simulation.ParticleSim"><code class="flex name class">
<span>class <span class="ident">ParticleSim</span></span>
<span>(</span><span>sim_size, cell_size, bg_img=None, bg_clr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Self-contained particle simulation.</p>
<p>On each call to <code>update()</code>, all particles in this simulation will be updated, then they will
be drawn onto an image that spans the entire simulation. By encapsulating the simulation like
this, it should be easier to change where the simulation is drawn within the program window
and to apply pan/zoom to the final image displayed to the user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sim_size</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Grid size of the simulation.</dd>
<dt><strong><code>cell_size</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Pixel size of each grid cell.</dd>
<dt><strong><code>bg_img</code></strong> :&ensp;<code>pygame.Surface</code></dt>
<dd>Background image for the simulation. Defaults to None.</dd>
<dt><strong><code>bg_clr</code></strong> :&ensp;<code>pygame.Color</code></dt>
<dd>Background color for the simulation. Defaults to None.</dd>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of smallest map chunks to use for optimization. Defaults to 8.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>pygame.Surface</code></dt>
<dd>The image corresponding to the current simulation state.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParticleSim():
    &#34;&#34;&#34;Self-contained particle simulation.

    On each call to `update()`, all particles in this simulation will be updated, then they will
    be drawn onto an image that spans the entire simulation. By encapsulating the simulation like
    this, it should be easier to change where the simulation is drawn within the program window
    and to apply pan/zoom to the final image displayed to the user.

    Args:
        sim_size (tuple): Grid size of the simulation.
        cell_size (tuple): Pixel size of each grid cell.
        bg_img (pygame.Surface): Background image for the simulation. Defaults to None.
        bg_clr (pygame.Color): Background color for the simulation. Defaults to None.
        chunk_size (int): Size of smallest map chunks to use for optimization. Defaults to 8.

    Attributes:
        image (pygame.Surface): The image corresponding to the current simulation state.
    &#34;&#34;&#34;

    # image: pygame.Surface

    def __init__(self, sim_size, cell_size, bg_img=None, bg_clr=None):
        # break the sim size into width and height, then make a 2D array of that size
        self._sim_size = Point(sim_size)
        self._sim_grid = [
            [None for x in range(self._sim_size.x)]
            for y in range(self._sim_size.y)]
        # break the cell size into width and height, then create a surface to draw the simulation
        # on. This surface will be big enough to draw the entire simulation on at 1x scale
        self._cell_width, self._cell_height = cell_size
        img_size = (self._sim_size.x*self._cell_width, self._sim_size.y*self._cell_width)
        self.image = pygame.Surface(img_size)
        # create a sprite group for all the particles and a list to track newly added particles
        self._particle_group = pygame.sprite.Group()
        self._update_group = pygame.sprite.Group()
        self._new_particles = []
        # set the background image that will be used when redrawing the sim
        self._background = None
        if bg_img is not None:
            self._background = pygame.transform.smoothscale(bg_img, img_size)
        elif bg_clr is not None:
            self._background = pygame.Surface(img_size)
            self._background.fill(bg_clr)
        else:
            print(&#39;Using default black background for sim&#39;)
            self._background = pygame.Surface(img_size)
            self._background.fill(&#39;black&#39;)

    def _get_abs_pos(self, pos):
        &#34;&#34;&#34;Get the absolute/pixel position that corresponds to a given grid position.

        Args:
            pos (Point, Point-like): The grid position to translate to an absolute position.

        Returns:
            Point: The absolute/grid position that corresponds to the given grid position.
        &#34;&#34;&#34;
        if not isinstance(pos, Point):
            pos = Point(pos)
        return Point(pos.x * self._cell_width, pos.y * self._cell_height)

    def in_bounds(self, pos):
        &#34;&#34;&#34;Check if a given grid position within the bounds of the grid.

        Args:
            pos (Point, Point-like): The grid position to check.

        Returns:
            bool: True if `pos` is in bounds, False otherwise.
        &#34;&#34;&#34;
        if not isinstance(pos, Point):
            pos = Point(pos)
        return Point(0, 0) &lt;= pos &lt; self._sim_size

    def clamp_pos(self, pos):
        &#34;&#34;&#34;Clamps a given grid position to be within bounds of the grid.

        Args:
            pos (Point, Point-like): The grid position to clamp.

        Returns:
            Point: The clamped grid position.
        &#34;&#34;&#34;
        if not isinstance(pos, Point):
            pos = Point(pos)
        return pos.clamp((0,0), self._sim_size)

    def get_cell(self, pos):
        &#34;&#34;&#34;Return the item held at a given grid position. Clamps the grid position if needed.

        Args:
            pos (Point, Point-like): The grid position to retrieve the value of.

        Returns:
            BaseParticle: The particle located at the given grid position.
            None: Returns `None` if there&#39;s no particle at the given grid position.
        &#34;&#34;&#34;
        if not isinstance(pos, Point):
            pos = Point(pos)
        if not self.in_bounds(pos):
            pos = self.clamp_pos(pos)
        return self._sim_grid[pos.y][pos.x]

    def move_particle(self, particle, pos):
        &#34;&#34;&#34;Moves a particle to a new grid position.

        Args:
            particle (BaseParticle): The particle to move.
            pos (Point, Point-like): The grid position to move the particle to.
        &#34;&#34;&#34;
        old = self.get_pos(particle.rect.topleft)
        self._sim_grid[old.y][old.x] = None
        if not isinstance(pos, Point):
            pos = Point(pos)
        self._sim_grid[pos.y][pos.x] = particle
        particle.rect.topleft = tuple(self._get_abs_pos(pos))

    def can_move(self, pos):
        return self.in_bounds(pos) and self.get_cell(pos) is None

    def get_pos(self, abs_pos):
        &#34;&#34;&#34;Get the grid position that corresponds to a given pixel position.

        Args:
            abs_pos (Point, Point-like): The pixel position to translate to a grid position.

        Returns:
            Point: The grid position that corresponds to the given pixel position.
        &#34;&#34;&#34;
        if not isinstance(abs_pos, Point):
            abs_pos = Point(abs_pos)
        return Point(abs_pos.x // self._cell_width, abs_pos.y // self._cell_height)

    def update(self, **kwargs):
        &#34;&#34;&#34;Update the simulation by one step.

        This updates all the particles in the simulation and redraws the current sim state.
        Newly created/added particles won&#39;t be updated, but they will be drawn. This prevents
        an &#39;invisible&#39; first update from occuring. The new particles then have their `dirty`
        attribute reset, since it doesn&#39;t reset automatically for some reason. This prevents
        them from being stuck for an extra frame.

        Args:
            **kwargs (any): Variable length list of keyword arguments. These arguments will be
                passed into each particle&#39;s `update()` function.
        &#34;&#34;&#34;
        for p in self._particle_group:
            if p in self._new_particles:
                continue
            if p.active and p not in self._update_group:
                self._update_group.add(p)
            if not p.active and p in self._update_group:
                self._update_group.remove(p)
        #if len(self._particle_group) &gt; 0:
        #    print(f&#39;Updating {100 * len(self._update_group) // len(self._particle_group)}% of all particles -- {len(self._update_group)} / {len(self._particle_group)}&#39;)
        self._update_group.update(**kwargs, sim=self)
        self.image.blit(self._background, (0, 0))
        self._particle_group.draw(self.image)
        self._new_particles = []

    def add_particle(self, particle, pos):
        &#34;&#34;&#34;Add a particle to the simulation at a given grid position.

        Newly added particles are added to a special list that gets cleared after each update.

        Args:
            particle (BaseParticle): The particle to add.
            pos (tuple): The grid position to add the particle at.

        Returns:
            bool: True if the particle was added, False otherwise.
        &#34;&#34;&#34;
        if not isinstance(pos, Point):
            pos = Point(pos)
        if self._sim_grid[pos.y][pos.x] is not None:
            return False
        self._particle_group.add(particle)
        self._sim_grid[pos.y][pos.x] = particle
        particle.rect.topleft = tuple(self._get_abs_pos(pos))
        self._new_particles.append(particle)
        return True

    def remove_particle(self, pos):
        if not isinstance(pos, Point):
            pos = Point(pos)
        if self._sim_grid[pos.y][pos.x] is None:
            return False
        p = self._sim_grid[pos.y][pos.x]
        p.activate()
        p.kill()
        self._sim_grid[pos.y][pos.x] = None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyparticles.engine.simulation.ParticleSim.add_particle"><code class="name flex">
<span>def <span class="ident">add_particle</span></span>(<span>self, particle, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a particle to the simulation at a given grid position.</p>
<p>Newly added particles are added to a special list that gets cleared after each update.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>particle</code></strong> :&ensp;<code>BaseParticle</code></dt>
<dd>The particle to add.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The grid position to add the particle at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the particle was added, False otherwise.</dd>
</dl></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.can_move"><code class="name flex">
<span>def <span class="ident">can_move</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.clamp_pos"><code class="name flex">
<span>def <span class="ident">clamp_pos</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Clamps a given grid position to be within bounds of the grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>Point, Point-like</code></dt>
<dd>The grid position to clamp.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Point</code></dt>
<dd>The clamped grid position.</dd>
</dl></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.get_cell"><code class="name flex">
<span>def <span class="ident">get_cell</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the item held at a given grid position. Clamps the grid position if needed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>Point, Point-like</code></dt>
<dd>The grid position to retrieve the value of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BaseParticle</code></dt>
<dd>The particle located at the given grid position.</dd>
<dt><code>None</code></dt>
<dd>Returns <code>None</code> if there's no particle at the given grid position.</dd>
</dl></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.get_pos"><code class="name flex">
<span>def <span class="ident">get_pos</span></span>(<span>self, abs_pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the grid position that corresponds to a given pixel position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>abs_pos</code></strong> :&ensp;<code>Point, Point-like</code></dt>
<dd>The pixel position to translate to a grid position.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Point</code></dt>
<dd>The grid position that corresponds to the given pixel position.</dd>
</dl></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.in_bounds"><code class="name flex">
<span>def <span class="ident">in_bounds</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a given grid position within the bounds of the grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>Point, Point-like</code></dt>
<dd>The grid position to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>pos</code> is in bounds, False otherwise.</dd>
</dl></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.move_particle"><code class="name flex">
<span>def <span class="ident">move_particle</span></span>(<span>self, particle, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves a particle to a new grid position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>particle</code></strong> :&ensp;<code>BaseParticle</code></dt>
<dd>The particle to move.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>Point, Point-like</code></dt>
<dd>The grid position to move the particle to.</dd>
</dl></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.remove_particle"><code class="name flex">
<span>def <span class="ident">remove_particle</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyparticles.engine.simulation.ParticleSim.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the simulation by one step.</p>
<p>This updates all the particles in the simulation and redraws the current sim state.
Newly created/added particles won't be updated, but they will be drawn. This prevents
an 'invisible' first update from occuring. The new particles then have their <code>dirty</code>
attribute reset, since it doesn't reset automatically for some reason. This prevents
them from being stuck for an extra frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>any</code></dt>
<dd>Variable length list of keyword arguments. These arguments will be
passed into each particle's <code>update()</code> function.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyparticles.engine" href="index.html">pyparticles.engine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyparticles.engine.simulation.ParticleSim" href="#pyparticles.engine.simulation.ParticleSim">ParticleSim</a></code></h4>
<ul class="two-column">
<li><code><a title="pyparticles.engine.simulation.ParticleSim.add_particle" href="#pyparticles.engine.simulation.ParticleSim.add_particle">add_particle</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.can_move" href="#pyparticles.engine.simulation.ParticleSim.can_move">can_move</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.clamp_pos" href="#pyparticles.engine.simulation.ParticleSim.clamp_pos">clamp_pos</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.get_cell" href="#pyparticles.engine.simulation.ParticleSim.get_cell">get_cell</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.get_pos" href="#pyparticles.engine.simulation.ParticleSim.get_pos">get_pos</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.in_bounds" href="#pyparticles.engine.simulation.ParticleSim.in_bounds">in_bounds</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.move_particle" href="#pyparticles.engine.simulation.ParticleSim.move_particle">move_particle</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.remove_particle" href="#pyparticles.engine.simulation.ParticleSim.remove_particle">remove_particle</a></code></li>
<li><code><a title="pyparticles.engine.simulation.ParticleSim.update" href="#pyparticles.engine.simulation.ParticleSim.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
